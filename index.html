<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Tachometer SVG Slider</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #ffffff;
            font-family: Arial, Helvetica, sans-serif;
        }

        .container {
            
            width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
            aspect-ratio: 5 / 4; /* Aspect ratio 4:3 */

        }

        /* vertical stacked: */
        .numberOfResults {
            font-size: 2vw;
            text-align: center; /* Center text within each label */
            font-weight: 300;
            position: relative;
            top: 2vw;

        }
        .questionHeader {
            /* height: 20vh; */
            font-size:4vw;
            position: relative;
            top: 6vw;
            text-align: center; /* Center text within each label */
            font-weight: 600;
            margin: 0 5vw 0 5vw;
        }
        .slider-container {
            width: 100vw;
            overflow: visible;
            z-index: 2;
        }
        .labels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            /* height: 18vh; */
            font-size:3vw;
            text-align: center; /* Center text within each label */
            font-size:3vw;
        }

        .slider {
            stroke: #E6F6FF;
            stroke-width: 6;
            fill: none;
        }
        .thumb {
            fill: #ffffff;
            cursor: pointer;
            stroke: #00447E; /* Adding a border color */
            stroke-width: 2; /* Border width */
            /* filter: drop-shadow(0px 0px 3px rgba(0, 0, 0, 0.3)); Adding shadow */
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0% {
                r: 13;
            }
            50% {
                r: 15;
            }
            100% {
                r: 13;
            }
        }
        .root {
            fill: #24B9D6;
            stroke: #ffffff; /* Adding a border color */
            stroke-width: 2; /* Border width */
        }
        .needle {
            fill: none;
            stroke:  #212121; /* Color of the needle */
            stroke-width: 5; /* Starting thickness of the needle */
            stroke-linecap: round; /* Makes the ends of the path rounded */
        }
        text {
            user-select: none;
        }


        .labels span {
            padding: 0 16%; /* Adds some padding for better spacing */
            overflow: hidden; /* Ensures text doesn't overflow */
        }
        #answer1 {
            text-align: left;
        }
        #answer2 {
            text-align: right;
        }
    </style>
</head>
<body>
    <div class="container">
        <div  class="numberOfResults">
            LIVE ABSTIMMUNG <span id="numberOfResultsDisplay"></span> MAL ABGESTIMMT 1
        </div>
        <div  class="questionHeader">
           <span id="question"></span>
        </div>
    <div class="slider-container">
        <svg id="sliderSVG" viewBox="0 0 300 150" preserveAspectRatio="xMidYMid meet" width="100%" height="100%" overflow="visible"> 
            <!-- Curved slider path -->
            <path id="sliderPath" d="M 50 150 A 100 100 0 0 1 250 150" class="slider"></path>

            <!-- Tachometer needle -->
            <line id="needle" x1="150" y1="150" x2="150" y2="75" class="needle"></line>

            <!-- Slider thumb -->
            <circle id="thumb" cx="150" cy="50" r="13" class="thumb"></circle>

            <!-- Slider root -->
            <circle id="root" cx="150" cy="150" r="10" class="root"></circle>

            <!-- Display value -->
            <text id="valueDisplay" x="150" y="10" text-anchor="middle" font-size="6" style="visibility: hidden;">Value: 0</text>

            <!-- Display 1/3 value -->
            <rect id="background1_3" x="80" y="112" width="20" height="10" fill="white" filter="url(#blur)" style="visibility: hidden;"></rect>
            <text id="valueDisplay1_3" x="90" y="120" text-anchor="middle" font-size="9" font-weight="bold"></text>


            <!-- Display 2/3 value -->
            <rect id="background2_3" x="140" y="72" width="20" height="10" fill="white" filter="url(#blur)" style="visibility: hidden;"></rect>
            <text id="valueDisplay2_3" x="150" y="80" text-anchor="middle" font-size="9" font-weight="bold"></text>


            <!-- Display 3/3 value -->
            <rect id="background3_3" x="200" y="112" width="20" height="10" fill="white" filter="url(#blur)" style="visibility: hidden;"></rect>
            <text id="valueDisplay3_3" x="210" y="120" text-anchor="middle" font-size="9" font-weight="bold" fill="black"></text>

            <defs>
                <filter id="blur" x="-100%" y="-100%" width="300%" height="300%">
                    <feGaussianBlur stdDeviation="1" />
                </filter>
              </defs>
        </svg>
    </div>
        <div class="labels">
            <span id="answer1"></span>
            <span id="answer2"></span>
        </div>
    </div>

    <script>
        const thumb = document.getElementById('thumb');
        const needle = document.getElementById('needle');
        const valueDisplay = document.getElementById('valueDisplay');

        const path = document.getElementById('sliderPath');
        const svg = document.getElementById('sliderSVG');
        const pathLength = path.getTotalLength();
        let userResult = null;
        let isDragging = false;
        let isSubmitting = false;
        let hasSubmitted = false;
        let lastThumbPosition = { x: 150, y: 50 };
        const needleLength = 75; // Constant length for the needle
        let entity = null; // apptive entitiy 
        // Desktop event listeners
        thumb.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', endDrag);

        // Mobile event listeners
        thumb.addEventListener('touchstart', startDrag);
        document.addEventListener('touchmove', onDrag);
        document.addEventListener('touchend', endDrag);

        function startDrag(e) {
            isDragging = true;
            e.preventDefault();
            thumb.style.animation = 'none'; // Remove the animation
        }

        function onDrag(e) {
            if (!isDragging) return;

            let clientX = e.clientX || e.touches[0].clientX;
            let clientY = e.clientY || e.touches[0].clientY;

            const svgPoint = getSVGPoint(clientX, clientY);
            const { x, y } = getClosestPointOnPath(svgPoint.x, svgPoint.y);

            thumb.setAttribute('cx', x);
            thumb.setAttribute('cy', y);

            const value = calculateValue(x, y);
            valueDisplay.textContent = `Value: ${value}`;
            userResult = value
            lastThumbPosition = { x, y }; // Store the final thumb position
        }

        function endDrag() {
            isDragging = false;
            if (userResult === null) return;
            if (hasSubmitted) {
                console.log('You have already submitted your answer.');
                return;
            }

            if (isSubmitting) {
                console.log('Submission is in progress. Please wait.');
                return;
            }
            
            animateNeedleToPosition(lastThumbPosition.x, lastThumbPosition.y);

            // Example usage:
            let data = {
                result: parseInt(userResult),
                entityId: entity['_id'],
                entity_uri: entity['_links']['self']['href'],
                // Add more key-value pairs as needed
            };
            isSubmitting = true;

            postDataToApptiveGrid(data)
                .then(result => {
                    console.log('Data successfully posted:', result);
                    hasSubmitted = true; // Mark as submitted
                    drawCircles();
                    calculatePercentages(entity);
                })
                .catch(error => {
                    console.error('Failed to post data:', error);
                }).finally(() => {
                    isSubmitting = false; // Reset submitting flag
                });
        }

        function getSVGPoint(x, y) {
            const point = svg.createSVGPoint();
            point.x = x;
            point.y = y;
            return point.matrixTransform(svg.getScreenCTM().inverse());
        }

        function getClosestPointOnPath(x, y) {
            let closestPoint = path.getPointAtLength(0);
            let minDist = distance(x, y, closestPoint.x, closestPoint.y);

            for (let i = 1; i < pathLength; i++) {
                const point = path.getPointAtLength(i);
                const dist = distance(x, y, point.x, point.y);
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = point;
                }
            }

            return closestPoint;
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function calculateValue(x, y) {
            const centerX = 150;
            const centerY = 150;

            // Calculate the angle from the center point (bottom of the arc)
            const angle = Math.atan2(y - centerY, x - centerX);

            if (angle == Math.PI) return 0;
            // Normalize angle to the range [0, Math.PI]
            // Math.PI corresponds to the leftmost point (0)
            // 0 corresponds to the rightmost point (10)
            const normalizedAngle = (angle + Math.PI) / Math.PI;

            // Scale the normalized angle to a value between 0 and 10
            const value = normalizedAngle * 9;
            
            // Round to the nearest integer
            return Math.round(value);
        }


        function animateNeedleToPosition(finalX, finalY) {
            const centerX = 150;
            const centerY = 150;

            const dx = finalX - centerX;
            const dy = finalY - centerY;

            const angle = Math.atan2(dy, dx);
            const targetX = centerX + needleLength * Math.cos(angle);
            const targetY = centerY + needleLength * Math.sin(angle);

            let startTime = null;

            function animate(time) {
                if (!startTime) startTime = time;
                const elapsed = time - startTime;

                const progress = Math.min(elapsed / 1000, 1); // 1000ms duration
                const bounceProgress = (p) => {
                    const n1 = 7.5625, d1 = 2.75;
                    if (p < 1 / d1) {
                        return n1 * p * p;
                    } else if (p < 2 / d1) {
                        return n1 * (p -= 1.5 / d1) * p + 0.75;
                    } else if (p < 2.5 / d1) {
                        return n1 * (p -= 2.25 / d1) * p + 0.9375;
                    } else {
                        return n1 * (p -= 2.625 / d1) * p + 0.984375;
                    }
                };

                const easedProgress = bounceProgress(progress);

                // Calculate the current angle during the animation
                const currentAngle = angle + (Math.PI / 8) * (1 - easedProgress) * Math.sin(easedProgress * Math.PI * 4);

                // Maintain constant needle length
                const currentX = centerX + needleLength * Math.cos(currentAngle);
                const currentY = centerY + needleLength * Math.sin(currentAngle);

                needle.setAttribute('x2', currentX);
                needle.setAttribute('y2', currentY);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            requestAnimationFrame(animate);
        }

        // Recalculate the value display, thumb position, and needle position on resize
        window.addEventListener('resize', () => {
            const thumbCX = parseFloat(thumb.getAttribute('cx'));
            const thumbCY = parseFloat(thumb.getAttribute('cy'));
            const value = calculateValue(thumbCX, thumbCY);
            valueDisplay.textContent = `Value: ${value}`;
            animateNeedleToPosition(thumbCX, thumbCY);
        });
        document.addEventListener("DOMContentLoaded", function() {
            const urlParams = new URLSearchParams(window.location.search);
            const url = urlParams.get('url') || 'https://app.apptivegrid.de/api/users/62398e23b8b578b35b971df0/spaces/66bcc1d7f549cad6d6dbf2be/grids/66bcc1dcf549ca6236dbf2c4/entities/BqWFtLCV6KM?layout=key';
            const username = urlParams.get('username') || '23bd064465e583233eab7807507a715c';
            const password = urlParams.get('password') || 'a7hkqxt2qj8rfverccyzn4agt';
            
            if (url && username && password) {
                const authHeader = 'Basic ' + btoa(username + ':' + password);
                
                fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': authHeader
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    return response.json(); // Parse the JSON data
                })
                .then(data => {
                    // Assuming 'question' is a key in the JSON response
                    entity = data;
                    document.getElementById('question').textContent = data['question'] || 'No question found in response.';
                    document.getElementById('answer1').textContent = data['answer_1'] || 'No answer_1 found in response.';
                    document.getElementById('answer2').textContent = data['answer_2'] || 'No answer_2 found in response.';
                    document.getElementById('numberOfResultsDisplay').textContent = data['numberOfResults']['value'] || 'No numberOfResults found in response.';
                })
                .catch(error => {
                    document.getElementById('valueDisplay').textContent = 'Fehler: ' + error.message;
                });
            } else {
                document.getElementById('valueDisplay').textContent = 'Fehler: URL, Benutzername oder Passwort fehlen in den Parametern.';
            }
    });

    async function postDataToApptiveGrid(data) {
        const url = entity['flow_uri'];

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // Include Authorization header if required
                    // 'Authorization': 'Bearer YOUR_ACCESS_TOKEN',
                },
                body: JSON.stringify(data) // Convert data to JSON string
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.data; // Assuming the response is JSON
            console.log('Success:', result);
            return result;
        } catch (error) {
            console.error('Error:', error);
            throw error;
        }
    }
    function drawCircles() {
            const svg = document.getElementById('sliderSVG');

            // Center and radius of the large circle
            const root = document.getElementById('root');
            const centerX = parseFloat(root.getAttribute('cx'));
            const centerY = parseFloat(root.getAttribute('cy'));
            const R_large = parseFloat(root.getAttribute('r'));

            // Base radius for small circles
            const r_small = 0.927 / 5 * R_large; // Adjusting the small circle radius proportionally

            // Draw multiple cascades of circles
            let currentRadius = R_large + r_small; // Starting radius for first cascade
            let cascade = 0;

            while (cascade < 20 ) { // Limit the cascades to a reasonable size
                // Calculate the circumference of the current cascade's circle
                const circumference =  Math.PI * currentRadius;

                // Calculate the number of circles that can fit in this circumference
                const numSmallCircles = Math.floor(circumference / (2 * r_small));

                // Angle between adjacent small circles
                const angleIncrement = (- Math.PI) / numSmallCircles;

                for (let i = 0; i <= numSmallCircles; i++) {
                    const angle = i * angleIncrement;
                    const smallCenterX = centerX + currentRadius * Math.cos(angle);
                    const smallCenterY = centerY + currentRadius * Math.sin(angle);

                    const smallCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    smallCircle.setAttribute('cx', smallCenterX);
                    smallCircle.setAttribute('cy', smallCenterY);
                    smallCircle.setAttribute('r', r_small);
                    smallCircle.setAttribute('stroke', 'white');
                    smallCircle.setAttribute('fill', 'grey');
                    
                    const sector = getSectorForAngle(angle);
                    const resultInSector = getResultForSector(sector);
                    console.log(`Resultes: ${resultInSector} in sector: ${sector}`);
                    if (resultInSector >= ((cascade / 2) * 10) ){
                        svg.insertBefore(smallCircle, svg.firstChild);
                    }
                }

                // Increase the radius for the next cascade
                currentRadius += 2 * r_small;
                cascade++;
            }
        }
        function getSectorForAngle(angle) {
            // Ensure the angle is between -Math.PI and 0
            if (angle > 0) angle = 0;
            if (angle < -Math.PI) angle = -Math.PI;
            
            // Map angle from [-Math.PI, 0] to [0, 10] in 11 steps
            const sectorValue = (angle + Math.PI) / Math.PI * 10;
            
            // Round to the nearest integer to get one of the 11 steps
            return Math.round(sectorValue);
        }
        function getResultForSector(sector){
            const result = entity[`${sector}`];
            const summOfResults = entity['numberOfResults']['value'];
            const percent =  Math.round((result / summOfResults) * 100 );
            const norm = normalize(percent);
            console.log(`Resultes: ${result} percent: ${percent} percent normalized: ${norm} in sector: ${sector}`);

            return norm
        }
        function normalize(percent) {
            let highestValue = getHighestValue(entity)
            const summOfResults = entity['numberOfResults']['value'];
            const highestValueInPercent =  Math.round((highestValue / summOfResults) * 100 );
            let normalized = (80 / highestValueInPercent) * percent ;
            return normalized ;
        }
        function getHighestValue(aEntity) {
            // Define the keys we are interested in
            const keys = ['0', '1', '2', '3', '4', '5' , '6', '7', '8', '9', '10'];

            // Use Math.max to find the highest value among the specified keys
            const highestValue = Math.max(...keys.map(key => aEntity[key]));

            return highestValue;
        
        }
        function calculatePercentages(data) {
            // Extract the total number of results
            const totalResults = data.numberOfResults.value;

            // Define the ranges
            const range1 = [0, 1, 2, 3];   // 0 to 3
            const range2 = [4, 5, 6];      // 4 to 6
            const range3 = [7, 8, 9, 10];  // 7 to 10

            // Sum the values in each range
            let sumRange1 = range1.reduce((sum, key) => sum + (data[key] || 0), 0);
            let sumRange2 = range2.reduce((sum, key) => sum + (data[key] || 0), 0);
            let sumRange3 = range3.reduce((sum, key) => sum + (data[key] || 0), 0);

            // Calculate the percentage for each range and round it to the nearest integer
            let percentageRange1 = Math.round((sumRange1 / totalResults) * 100);
            let percentageRange2 = Math.round((sumRange2 / totalResults) * 100);
            let percentageRange3 = Math.round((sumRange3 / totalResults) * 100);

            // Return the results as an object
            let result = {
                range_0_3: percentageRange1 + '%',
                range_4_6: percentageRange2 + '%',
                range_7_10: percentageRange3 + '%'
            };
            const valueDisplay1_3 = document.getElementById('valueDisplay1_3');
            const valueDisplay2_3 = document.getElementById('valueDisplay2_3');
            const valueDisplay3_3 = document.getElementById('valueDisplay3_3');
            valueDisplay1_3.textContent = result.range_0_3;
            valueDisplay2_3.textContent = result.range_4_6;
            valueDisplay3_3.textContent = result.range_7_10;

            // show a background 
            document.getElementById('background1_3').style.visibility = 'visible';
            document.getElementById('background2_3').style.visibility = 'visible';
            document.getElementById('background3_3').style.visibility = 'visible';

        }

</script>
</body>
</html>
